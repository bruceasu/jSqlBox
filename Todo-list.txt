*.当存在masters，当switch到其它Runner时，这是两个不同的数据源，jTransactions现在只能处理一个数据源，不能为每个Master都注册一个TxBox.class了，出现跨库操作这种分布式事务怎么处理? 几种方案：
  1.不管，其它的Runner工作在非事务模式，通过分库键保证相关业务配置在同一个库中，不存在一个业务中出现分库读写的情况，即相同业务聚合在同一个库中。TxBox.class配置成支持多数据源，但只有当前库的Runner有回滚功能。(本身已支持)
  2.如果必须一个业务要读写多个库，TxBox.class配置成支持多数据源，这时分布式事务XA（如atomikos)可以用上，在jTransactions中填加分布式事务atomikos整合演示 （已完成)
  3.如果必须一个业务要读写多个库，TxBox.class配置成支持多数据源，借签阿里GTS,采用TCC事务模式。(对业务入侵大，不象阿里有专有数据库进行快照、恢复功能，ORM层要提供快照、日志、恢复功能。) (以后再说)


* 增加Java8利用lambda语法实现懒加载的示例。
    如果一个User类中有一个OrderList属性，当仅仅查询出User实例时，OrderList属性为空，这时可以用user.loadProperty(User::OrderList [, SqlItem... optionals])来手工加载它。
	如果一个User类中有一个Teacher属性，当仅仅查询出User实例时，Teacher属性为空，这时可以用user.loadProperty(User::Teacher [, SqlItem... optionals])来手工加载它。
    如果是Java6, 可以用user.loadProperty("teacherField", SqlItem... optionals])来手工加载	    
