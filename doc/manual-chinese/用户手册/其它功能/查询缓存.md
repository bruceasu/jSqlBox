jSqlBox的查询缓存是通过Handler类来实现的，而且只针对查询方法生效，第一次查询时读取数据库，后续的查询将会从缓存中读取。缓存的使用可能会造成脏数据，即缓存中的值与实际数据库中的值不一致，使用时要注意。使用jSqlBox的查询缓存功能，通常是手工在查询方法中加入Handler类，例如：
```
List<DemoUser> result = ctx.nQuery(
  new Wrap(new EntityListHandler(DemoUser.class), new SimpleCacheHandler()),
	 "select u.** from DemoUser u where u.age>?", 0);
```
jSqlBox自带的缓存器SimpleCacheHandler是个简单的LRU缓存，利用内存中的LinkedHashMap表来缓存SQL查询结果，当缓存存满数据时，会把最久没有被访问到的数据清除掉，SimpleCacheHandler有两种构造方式：
```
SimpleCacheHandler()
SimpleCacheHandler(int aliveSeconds)
```
后一种构造方式允许设定缓存失效时间，单位是秒（内部会向上取值调整成与1、10、100、1000...最接近的值)。如果采用第一种无参构造器，默认缓存失效时间是1000秒。

另一种缓存使用方式是在SqlBoxContext构造时将缓存SimpleCacheHandler类设置成全局缓存，如:
```
SqlBoxContextConfig config=new SqlBoxContextConfig();
config.setHandlers(new SimpleCacheHandler());
SqlBoxContext ctx=new SqlBoxContext(ds, config);
```
这样就不必每次在查询方法中手工加入缓存Handler了，但是因为缓存有可能造成脏数据的存在，这种方式通常不应该参与事务操作，也就是说，可以单独创建一个支持缓存的SqlBoxContext，给它专门分配一个数据源，平时只做查询。  

SimpleCacheHandler只允许存放最多500条记录，如果想要编写自已的缓存Handler类，必须同时实现ResultSetHandler和CacheSqlHandler两个接口，可以参考SimpleCacheHandler类的源码。  

jSqlBox的查询缓存机制比较简单，与MyBatis一样，它是粗粒度的，不是针对行集的，缓存的主键采用SQL+参数这种方式, 只要SQL拼写或参数值有任意一点不同，jSqlBox即认为这是两个不同的查询，因此哪些查询需要使用缓存需要仔细考虑，参数经常变化的查询不应该使用缓存。  

如果想要建立一个针对行集的缓存，可以考虑在内存中保持一个EntityNet实例，并打开它的EntityNet实例的查询缓存，这样可以随时用NoSQL查询访问它，这相当于在内存中建立了一个图数据库。但是要注意两点：1.EntityNet不是线程安全的，所以不要多个线程同时修改它 2.不能载入很大的数据量，因为EntityNet的查询缓存也可能撑爆内存。

