jSqlBox同时支持固定配置和动态配置，这是它的一个特点。

先看一下固定配置:
```
@Table(name = "emailtb")
public class Email{ 
	@Id
	String id;
	String emailName;

	@SingleFKey(refs = { "usertb", "id" })
	String userId;
        ......
}          
```
jSqlBox是一个ORM工具，这意味着对于一个实体Bean如上面的Email类来说，它必须知道这个类对应哪一个数据库表，以及每个实体属性对应数据库表的哪一个列，以及各个列与其它表格之间的外键约束(对jSqlBox来说可以利用来进行关联查询，详见NoSQL查询一节），通过Annotation注解，可以达到这个目的。但是这种注解方式的配置，是很难在运行期改变的，笔者称其为固定配置，例如Hibernate中的XML配置，在运行期是很难改变的，所以是一种固定配置。固定配置的优点是工作量少，整个项目配置一次即可，缺点是不灵活，例如Hibernate的配置只能对一个实体有一种配置，当实体间关联关系不确定时或需要临时改变时就很难处理。而MyBatis的对策是对应不同的查询，临时创建不同的XML配置，看起来灵活，但带来的后果是每做一个复杂的关联查询就要建一个XML，其中的字段名、属性名等大量重复，增加了很多不必要的工作量。  

当持久层工具将注解或XML配置的内容读入内存并解析后，生成Java对象，并公开它的存取方法，允许在运行期改变配置，称为动态配置，目前很少有持久层工具做到这点。  

jSqlBox同时支持固定配置和动态配置，利用固定配置打下整个项目配置的基础，对于需要临时改变配置的场合下，可以在运行期改变固定配置，获得一个改动后的副本，这种改变只需要作少许改动即可，工作量很少，因此jSqlBox同时具有了固定配置和动态配置的优点。  

jSqlBox的固定配置和动态配置功能，是由jDialects模块来承担，这是一个可以独立使用的数据库建模工具，可以根据注解或Java方法来建立一个和具体数据库无关模型的功能，这个模型也被jSqlBox利用来在运行期动态修改，而且修改它的Java方法和建立它的Java方法是一样的，因为是同一个类的方法。    
以下示例中，固定和动态方法穿插使用, config方法是针对实体类的固定配置方法(这是jDialects中的一个约定)，UserDemoSqlBox (即类名+SqlBox这种格式）是针对实体类的固定配置方法(这是jSqlBox中的一个约定，配置可以写在类的外面），u.columnModel("id").pkey();这个方法在运行期动态添加主键，则属于动态配置，但是静态和动态配置都使用相同的语法。
```
public class DynamicConfigTest extends TestBase {
	public static class UserDemo extends ActiveRecord {
		@UUID32
		private String id;

		@Column(name = "user_name2", length = 32)
		private String userName;
               
                ......

		public static void config(TableModel t) {
			t.setTableName("table2");
			t.column("user_name2").setColumnName("user_name3");
		}
	}

	public static class UserDemoSqlBox extends SqlBox {
		{
			TableModel t = TableModelUtils.entity2Model(UserDemo.class);
			t.addColumn("anotherColumn1").STRING(40);
			this.setTableModel(t);
		}
	}

	@Test
	public void doTest() { 
		UserDemo u = new UserDemo();  
		u.columnModel("id").pkey();
		u.setUserName("Sam");
		ctx.insert(u); 
	}
}
```

关于动态配置，NoSQL查询一节已经看到了它的应用，可以在运行期动态添加、删除外键约束，实现灵活的对象间关联查询，而不需要对于每一个查询，从头到尾创建一个复杂的注解、XML之类的配置。

另外对于实体来说，在运行期动态改变它的SqlBoxContext上下文实例也是一种特殊的动态配置，例如：user.userContext(ctx)这种用法，这相当于可以在运行期动态切换数据源。对于纯POJO类实体，可以用SqlBoxUtils.findBox(entity)方法来获取它的配置，这是一个SqlBox对象，有SqlBoxContext和TableModel两个属性。  