jSqlBox默认工作于自动提交模式，要让它工作于事务模式，通常有三种方式，第一种是手工进行事务的开启和关闭, 示例如下：
```
 SqlBoxContext ctx=new SqlBoxContext();
 Connection conn= null;
 try {
	conn= dataSource.getConnection();
	conn.setAutoCommit(false);
	ctx.update(conn, 'update users set age=5');
        ......
	conn.commit();
 } catch (SQLException e) {
	conn.rollback();
 } finally {
	ctx.close(conn);
 }
```
以上方式局限性比较大，因为方法中必须传一个Connection参数，而且使用起来比较烦琐，实际项目中很少采用。

第二种方式是使用Spring提供的TransactionAwareDataSourceProxy，这个是通过在DataSource上设置代理来实现声明式事务，适合于老程序改造，本人不是太喜欢这种模式，所以这里不作详细介绍。

第三种方式就是本文重点要介绍的声明式事务，通过在构建SqlBoxContext时给它设定一个支持声明式事务的连接管理器，下面通过一个实际的例子来说明jSqlBox的声明式事务配置(下例中的源码可以在demo目录下的jBooox项目中找到)：  
声明式事务需要一个IOC/AOP工具支持，先在pom.xml中添加一个IOC/AOP工具，这里用的是jBeanBox(用Spring也是类似的)：
```
    <dependency>
        <groupId>com.github.drinkjava2</groupId>
        <artifactId>jBeanBox</artifactId>
        <version>1.0.7</version>
    </dependency>
```
配置代码：
```
public class Initializer implements ServletContextListener {

	public static class DataSourceBox extends BeanBox {
		{	setProperty("jdbcUrl", "jdbc:h2:mem:DBName;MODE=MYSQL;DB_CLOSE_DELAY=-1;TRACE_LEVEL_SYSTEM_OUT=0");
			setProperty("driverClassName", "org.h2.Driver");
			setProperty("username", "sa");
			setProperty("password", "");
		}

		public HikariDataSource create() {
			HikariDataSource ds = new HikariDataSource();
			ds.addDataSourceProperty("cachePrepStmts", true);
			ds.addDataSourceProperty("prepStmtCacheSize", 250);
			ds.addDataSourceProperty("prepStmtCacheSqlLimit", 2048);
			ds.addDataSourceProperty("useServerPrepStmts", true);
			ds.setMaximumPoolSize(10);
			ds.setConnectionTimeout(5000);
			this.setPreDestory("close");// jBeanBox will close pool
			return ds;
		}
	}

	public static class TxBox extends BeanBox {
	  {
            this.setConstructor(TinyTx.class, BeanBox.getBean(DataSourceBox.class),
			        Connection.TRANSACTION_READ_COMMITTED);
	  }
	}

	@Override
	public void contextInitialized(ServletContextEvent context) {
		BeanBox.regAopAroundAnnotation(TX.class, TxBox.class);
		SqlBoxContextConfig config = new SqlBoxContextConfig();
		config.setConnectionManager(TinyTxConnectionManager.instance());
		SqlBoxContext ctx = new SqlBoxContext((DataSource) BeanBox.getBean(DataSourceBox.class), config);
		SqlBoxContext.setGlobalSqlBoxContext(ctx);
	}

	@Override
	public void contextDestroyed(ServletContextEvent context) {
		SqlBoxContext.setGlobalSqlBoxContext(null);
		BeanBox.defaultContext.close(); 
	}

}
```

简单来说，jSqlBox事务配置最核心的几步就是这几句代码：
```
BeanBox.regAopAroundAnnotation(TX.class, TxBox.class);
SqlBoxContextConfig config = new SqlBoxContextConfig();
config.setConnectionManager(TinyTxConnectionManager.instance());
SqlBoxContext ctx = 
  new SqlBoxContext((DataSource) BeanBox.getBean(DataSourceBox.class), config);
```
以下是对这个例子中声明式事务配置比较详细的介绍，写的比较啰嗦，对声明式事务比较熟悉的同学们可以快速扫一眼就行了：
* 使用声明式事务，前提是要有一个IOC/AOP工具以提供实现切面编程支持，这个例子是使用jBeanBox，如果想要知道如何使用Spring以及利用Spring事务对jSqlBox进行声明式事务配置，请详见demo目录下的jsqlbox-in-spring演示项目。
* 首先要保证在项目启动时进行配置，这个例子是一个web项目，通过实现ServletContextListener接口并在web.xml中配置保证配置代码最先运行。
* 然后是数据源，通常配置成单例模式，这里是用H2内存数据库+HikariDataSource数据池来演示。注意数据池在项目结束后或每个单元测试后不要忘了关闭，上例中"this.setPreDestory("close");" 代码表示如果jBeanBox环境关闭，将调用数据池的close方法。当Web项目结束后contextDestroyed方法被调用，然后jBeanBox环境关闭，数据池的close方法会被调用。
* TxBox是一个单例，用于事务切面处理，它的第一个参数是一个TinyTx表明使用了jTransactions项目中的TinyTx类，它的构造器接收一个数据源和一个事务类型参数。
* TX是一个AOP环绕注解，BeanBox.regAopAroundAnnotation(TX.class, TxBox.class)方法将AOP注解与一个事务切面处理类(这里是TxBox类)绑定在一起。如果TX注解标注在某个类的方法上，而且这个类是用BeanBox.getBean(某类.class)这种方式去创建对象，则会得到一个代理类实例，代理类实例的被TX标注的方法将由TxBox对应的实例来处理，这是声明式事务的工作基本原理。
* 如果不想使用缺省的TX注解，例如换成@Transaction之类的名字，可以自定义AOP注解，详见[这里](../blob/master/demo/jbooox/src/main/java/com/jsqlboxdemo/init/Initializer.java)。
* 为了让SqlBoxContext知道使用声明式事务，需要配置它的连接管理器，通常情况下，jSqlBox会调用DataSource的getConnection方法来获取一个连接(Connection)以操作数据库，当配置连接管理器后，获取Connection的工作交给了连接管理器，在这个例子中是TinyTxConnectionManager的一个单例。
* 这里用到了jTransaction模块中的两个对象，TinyTx和TinyTxConnectionManager，这是两个配对的对象，孟不离焦，焦不离孟，一个负责用来处理事务方法的切面回调，一个用来获取和释放连接，它们之间的沟通是以同一个DataSource为纽带，TinyTx自已保存了一份DataSource，而TinyTxConnectionManager呢，则采用保存在SqlBoxContext中的DataSource。 
* jTransaction是一个独立的、小巧的声明式事务工具，其中的TinyTx源码只有几个类而已，如果想要换成使用Spring的事明式事务，则除了两个配对的对象换成SpringTx和SpringTxConnectionManager，以及添加Spring的库依赖外，本文其它的介绍都适用。